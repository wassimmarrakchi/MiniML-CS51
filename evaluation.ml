(*
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2018
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;

(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(*Exception for evaluator runtime, generated by an explicit "raise" construct*)
exception EvalException ;;


(*......................................................................
  Environments and values
 *)

module type Env_type = sig
    type env
    type value = | Val of expr
                 | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value = | Val of expr
                 | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value = Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      match List.find_opt (fun n -> (fst n) = varname) env with
      | Some v -> !(snd v)
      | None -> raise (EvalError "Env.lookup: Unbound variable.")

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env : env) (varname : varid) (loc : value ref) : env =
      (varname, loc) :: env

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with
      | Val e -> "Val (" ^ exp_to_abstract_string e ^ ")"
      | Closure (e, env) ->
        "Closure " ^
        let str = exp_to_abstract_string e in
        if printenvp then " (" ^ str ^ ", " ^ env_to_string env ^ ")"
        else "(" ^ str ^ "); "

    (* Returns a printable string representation of an environment *)
    and env_to_string (env : env) : string =
      match env with
      | [] -> ""
      | hd :: tl ->
        "(" ^ fst hd ^ ", " ^ value_to_string !(snd hd) ^ "); " ^
        env_to_string tl ;;
  end
;;

open Env ;;

(*......................................................................
  Evaluation functions

  Returns a result of type value of evaluating the expression exp
  in the environment env. We've provided an initial implementation
  for a trivial evaluator, which just converts the expression
  unchanged to a value and returns it, along with "stub code" for
  three more evaluators: a substitution model evaluator and dynamic
  and lexical environment model versions.

  Each evaluator is of type expr -> Env.env -> Env.value for
  consistency, though some of the evaluators don't need an
  environment, and some will only return values that are "bare
  values" (that is, not closures). *)

(* The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)

let eval_t (exp : expr) (_env : Env.env) : Env.value =
  (* coerce the expr, unchanged, into a value *)
  Env.Val exp ;;

(* Evaluates basic exps for all models; specific expressions evals are later *)
let rec evaluate (eval) (exp : expr) (env : Env.env) =
  let deval (exp : expr) =
    match eval exp env with
    | Val x -> x
    | _ -> raise (EvalError "Evaluate: This shouldn't have happened.")
  in
  match exp with
  | Var x -> lookup env x
  | Num _ | Bool _ | Raise | Unassigned -> Val exp
  | Fun _ -> Val exp
  | Conditional (e1, e2, e3) ->
    (match eval e1 env with
     | Val (Bool b) -> if b then eval e2 env else eval e3 env
     | _ -> raise (EvalError "Something went wrong in Conditional Evaluation"))
  | Unop (Negate, e) -> evaluate eval (Binop (Times, Num ~-1, deval e)) env
  | Binop (op, exp1, exp2) ->
    let opnum n =
      match deval exp1, deval exp2 with
      | Num n1, Num n2 -> Num (n n1 n2)
      | _ -> raise (EvalError "Only INT was implemented for calculations")
    in
    (match op with
     | Plus -> Val (opnum (+))
     | Minus -> Val (opnum (-))
     | Times -> Val (opnum ( * ))
     | LessThan ->
       (match deval exp1, deval exp2 with
        | Bool b1, Bool b2 -> Val (Bool (b1 < b2))
        | Num n1, Num n2 -> Val (Bool (n1 < n2))
        | _ -> failwith "Only INT was implemented for calculations")
     | Equals ->
       match deval exp1, deval exp2 with
       | Bool b1, Bool b2 -> Val (Bool (b1 = b2))
       | Num n1, Num n2 -> Val (Bool (n1 = n2))
       | _ -> failwith "Only INT was implemented for calculations")
  | Let (id, def, body) -> eval body (extend env id (ref (eval def env)))
  | _ -> raise (EvalError "This function only takes care of basic evals") ;;

(* The SUBSTITUTION MODEL evaluator -- to be completed *)

(* We can't compare two booleans. Letrec isn't working (might be because of
   these first problem). *)

let rec eval_s (exp : expr) (_env : Env.env) : Env.value =
  let inner exp = eval_s exp _env in
  let deval_s (exp : expr) =
    match inner exp with
    | Val x -> x
    | _ -> raise (EvalError "Deval_s: This shouldn't have happened.")
  in
  match exp with
  | Var _ -> raise (EvalError "Eval_s: Unbound variable")
  | Fun _ | Raise | Unassigned | Num _ | Bool _ | Conditional _ | Binop _
  | Unop _ -> evaluate eval_s exp _env
  | Let (id, def, body) -> inner (subst id def body)
  | App (e1, e2) ->
    (match deval_s e1 with
     | Fun (id, def) -> inner (subst id (deval_s e2) def)
     | _ -> raise (EvalError "App in eval_s: Application by a non-function."))
  | Letrec (id, def, body) ->
    match inner (subst id (Letrec (id, def, Var id)) def) with
    | Val x -> inner (subst id x body)
    | _ -> raise (EvalError "Closures are not part of our eval_s model.")

(* The DYNAMICALLY-SCOPED ENVIRONMENT MODEL evaluator -- to be
   completed *)

let rec eval_d (exp : expr) (env : Env.env) : Env.value =
  match exp with
  | Var _ |Fun _ | Num _ | Bool _ | Raise | Unassigned | Conditional _
  | Binop _ | Unop _ | Let _ -> evaluate eval_d exp env
  | App (e1, e2) ->
    (match eval_d e1 env with
     | Val (Fun (id, e)) -> eval_d e (extend env id (ref (eval_d e2 env)))
     | _ -> raise (EvalError "App in eval_d: Application by non-function."))
  | Letrec (id, def, body) ->
    (match eval_d def (extend env id (ref (Val Unassigned))) with
     | (Val (Var i)) as v ->
       if i = id then raise (EvalError "The definition evaluated to varid.")
       else eval_d body (extend env id (ref v))
     | _ as v -> eval_d body (extend env id (ref v))) ;;

(* The LEXICALLY-SCOPED ENVIRONMENT MODEL evaluator -- optionally
   completed as (part of) your extension *)

let rec eval_l (exp : expr) (env : Env.env) : Env.value =
  match exp with
  | Var _ | Num _ | Bool _ | Raise | Unassigned | Binop _ | Unop _
  | Conditional _ | Let _ -> evaluate eval_l exp env
  | Fun _ -> close exp env
  | Letrec (id, def, body) ->
    let id_val = ref (Val Unassigned) in
    let env = extend env id id_val in
    id_val := eval_l def env;
    eval_l body env
  | App (e1, e2) ->
    (match eval_l e1 env with
     | Closure (Fun (id, e1), envc) ->
       eval_l e1 (extend envc id (ref (eval_l e2 env)))
     | _ -> raise (EvalError "App in eval_l: Application by non-function."))


(* Connecting the evaluators to the external world. The REPL in
   miniml.ml uses a call to the single function evaluate defined
   here. Initially, evaluate is the trivial evaluator eval_t. But you
   can define it to use any of the other evaluators as you proceed to
   implement them. (We will directly unit test the four evaluators
   above, not the evaluate function, so it doesn't matter how it's set
   when you submit your solution.) *)

let evaluate = eval_l ;;
